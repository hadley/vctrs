% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slice-chop.R
\name{vec_unchop}
\alias{vec_unchop}
\title{Combine a list of vectors}
\usage{
vec_unchop(
  x,
  indices = NULL,
  ptype = NULL,
  name_repair = c("minimal", "unique", "check_unique", "universal")
)
}
\arguments{
\item{x}{A vector}

\item{indices}{A list of index values to slice \code{x} with, or \code{NULL}. Each
element of the list must be an integer, character or logical vector that
would be valid as an index in \code{\link[=vec_slice]{vec_slice()}}. If \code{NULL}, \code{x} is split into
its individual elements, equivalent to using an \code{indices} of
\code{as.list(vec_seq_along(x))}.}

\item{ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type across all elements of \code{...}.

Alternatively, you can supply \code{.ptype} to give the output known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{name_repair}{How to repair names, see \code{repair} options in \code{\link[=vec_as_names]{vec_as_names()}}.}
}
\description{
\code{vec_unchop()} combines \code{x}, a list of vectors, into a single vector, placing
elements in the output according to the locations specified by \code{indices}. It
is similar to \code{\link[=vec_c]{vec_c()}}, but gives greater control over how the elements
are combined, and does not respect outer names on the list.
}
