---
title: "Proxy generics"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Proxy generics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(vctrs)
```

vctrs provides two "proxy" generics that allow you to declare that your class have possesses certain properties. A proxy function returns a simple object (typically either a bare vector or a data frame), that possesses the same properties as your class. This permits efficient implementation of the vctrs internals because once you have the proxy object, all code can be written in C.

* `vec_proxy_equal()` specifies how to test the elements of your for equality. 
  This proxy underpins `==` and `!=`, but also `unique()`, `anyDuplicated()`, 
  and `is.na()`.

* `vec_proxy_compare()` specifies how to compare the elements of your vector.
  This proxy is used in `<`, `<=`, `>=`, `>`, `min()`, `max()`, `median()`, 
  `quantile()`, and `xtfrm()` methods. (And `xtfrm()` is used in `order()` and 
  `sort()`.)

vctrs also provides two mathematical generics that allow you to define a broad swath of mathematical behaviour at once:

*  `vec_math()` specifies the behaviour of mathematical functions like 
   `abs()`, `sum()`, and `mean()`.
   
*  `vec_arith()` specifies the behaviour of the arithmetic operations like
   `+`, `-`, and `%%`.

Where possible, it's a good idea to define methods for these generics because you get a lot of behaviour for relatively little work.

## Rational

To explore these ideas we'll use the rational class which was introduced in `vignette("s3-vector")`. Here's the basic defintion of the class:

```{r}
new_rational <- function(n = integer(), d = integer()) {
  stopifnot(is.integer(n))
  stopifnot(is.integer(d))
  
  new_rcrd(list(n = n, d = d), class = "vctrs_rational")
}
rational <- function(n, d) {
  shape <- vec_shape(n, d)
  
  n <- vec_reshape(vec_cast(n, integer()), shape)
  d <- vec_reshape(vec_cast(d, integer()), shape)
  
  new_rational(n, d)
}
format.vctrs_rational <- function(x, ...) {
  n <- field(x, "n")
  d <- field(x, "d")
  
  out <- paste0(n, "/", d)
  out[is.na(n) | is.na(d)] <- NA
  
  out
}

vec_ptype_abbr.vctrs_rational <- function(x) "rtnl"
vec_ptype_full.vctrs_rational <- function(x) "rational"
```

```{r}
vec_type2.vctrs_rational <- function(x, y) UseMethod("vec_type2.vctrs_rational", y)
vec_type2.vctrs_rational.default <- function(x, y) stop_incompatible_type(x, y)
vec_type2.vctrs_rational.vctrs_rational <- function(x, y) x

vec_cast.vctrs_rational <- function(x, to) UseMethod("vec_cast.vctrs_rational")
vec_cast.vctrs_rational.default <- function(x, to) stop_incompatible_cast(x, y)
vec_cast.vctrs_rational.vctrs_rational <- function(x, to) x
```

### Equality

By default, `vec_proxy_equal()` converts a record to a data frame:

```{r}
x <- rational(c(1, 2, 1, 2), c(1, 1, 2, 2))
x

vec_proxy_equal(x)
```

And the default comparison is column by column:

```{r}
x == rational(1, 1)
```

This is an ok default, but doesn't do exactly what we want here because `rational(1, 1)` represents the same number as `rational(2, 2)` so they should be equal. We can fix that by dividing `n` and `d` by their greatest common divisor:

```{r}
# Thanks to Matthew Lundberg: https://stackoverflow.com/a/21504113/16632 
gcd <- function(x, y) {
  r <- x %% y
  ifelse(r, gcd(y, r), y)
}

vec_proxy_equal.vctrs_rational <- function(x) {
  n <- field(x, "n")
  d <- field(x, "d")
  gcd <- gcd(n, d)
  
  data.frame(n = n / gcd, d = d / gcd)
}
vec_proxy_equal(x)

x == rational(1, 1)
```

### Comparison

Again, the default comparison proxy is just the elements:

```{r}
vec_proxy_compare(x)
```
So sorting doesn't give us increasing order:

```{r}
sort(x)
```

Here the easiest fix is to simply compute the fraction and then sort that real number:

```{r}
vec_proxy_compare.vctrs_rational <- function(x) {
  field(x, "n") / field(x, "d")
}

sort(x)
```

(We could have used that technique for equality, but due to floating point computation it's not necessarily true that `x == y` implies that `d * x == d * y`.)

## Polynomial

```{r}
new_poly <- function(x) {
  new_list_of(x, ptype = integer(), class = "vctrs_poly")
}

poly <- function(...) {
  x <- list(...)
  x <- lapply(x, vec_cast, integer())
  new_poly(x)
}

vec_ptype_full.vctrs_poly <- function(x) "polynomial"
vec_ptype_abbr.vctrs_poly <- function(x) "poly"

format.vctrs_poly <- function(x, ...) {
  format_one <- function(x) {
    if (length(x) == 0) {
      return("")
    } else if (length(x) == 1) {
      format(x)
    } else {
      suffix <- c(paste0("\u22C5x^", seq(length(x) - 1, 1)), "")
      out <- paste0(x, suffix)
      out <- out[x != 0L]
      paste0(out, collapse = " + ")
    }
  }
  vapply(x, format_one, character(1))
}

vec_print_data.vctrs_poly <- function(x) {
  if (length(x) == 0)
    return()
  print(format(x), quote = FALSE)
}

p <- poly(1, c(1, 0, 1), c(1, 0, 0, 0, 2))
p
```

Equality works out of the box because we can tell if two integer vectors are equal:

```{r}
p == poly(c(1, 0, 1))
```

But we can't order them, because lists are not comparable:

```{r, error = TRUE}
sort(p)
```

So we need to define a `vec_proxy_compare()` method:

```{r}
vec_proxy_compare.vctrs_poly <- function(x) {
  x_raw <- vec_data(x)
  # First figure out the maximum length
  n <- max(vapply(x_raw, length, integer(1)))
  
  # Then expand all vectors to this length by filling in with zeros
  full <- lapply(x_raw, function(x) c(rep(0L, n - length(x)), x))
  
  # Then turn into a data frame
  as.data.frame(do.call(rbind, full))
}

sort(poly(3, 2, 1))
sort(poly(1, c(1, 0, 0), c(1, 0)))
```

## Period and frequency

```{r}
period <- function(x) {
  x <- vec_cast(x, double())
  new_vctr(x, class = "vctrs_period")
}
format.vctrs_period <- function(x) {
  paste0(format(vec_data(x)), " s")
}

freq <- function(x) {
  x <- vec_cast(x, double())
  new_vctr(x, class = "vctrs_frequency")
}
format.vctr_frequency <- function(x) {
  paste0(format(vec_data(x)), " Hz")
}

period(0.1)
freq(10)
```


```{r}
vec_arith.vctr_frequency <- function(op, x, y) {
  UseMethod("vec_arith.vctr_frequency", y)
}
vec_arith.vctrs_frequency.default <- function(op, x, y) {
  stop_incompatible_op(op, x, y)
}
vec_arith.vctrs_period <- function(op, x, y) {
  UseMethod("vec_arith.vctrs_period", y)
}
vec_arith.vctrs_period.default <- function(op, x, y) {
  stop_incompatible_op(op, x, y)
}
```

```{r}
vec_arith.vctrs_period.vctrs_period <- function(op, x, y) {
  switch(op,
    `-` = ,
    `+` = vec_restore(vec_arith_base(op, x, y), x),
    stop_incompatible_op(op, x, y)
  )
}
vec_arith.vctrs_period.numeric <- function(op, x, y) {
  switch(op,
    `-` = ,
    `+` = ,
    `*` = ,
    `/` = vec_restore(vec_arith_base(op, x, y), x),
    stop_incompatible_op(op, x, y)
  )
}
vec_arith.numeric.vctrs_period <- function(op, x, y) {
  switch(op,
    `*` = vec_restore(vec_arith_base(op, x, y), y),
    `/` = freq(vec_arith_base(op, x, y)),
    stop_incompatible_op(op, x, y)
  )
}

period(1) + period(1)
2 * period(10)
period(10) / 5
5 / period(10)
```


## Intervals

First, we implement an interval class, a record composed of `l`eft and `r`ight fields. As usual, we make a low-level constructor, a user-friend constructor, and define a format method.

```{r}
new_interval <- function(l, r) {
  stopifnot(is.double(l), is.double(r))
  new_rcrd(list(l = l, r = r), class = "vctrs_interval")
}
interval <- function(l, r) {
  c(l, r) %<-% as.list(vec_coerce(l, r, .ptype = double()))
  c(l, r) %<-% vec_recycle(l, r)
  c(l, r) %<-% list(pmin(l, r), pmax(l, r))
  new_interval(l, r)
}
format.vctrs_interval <- function(x, ...) {
  l <- field(x, "l")
  r <- field(x, "r")
  
  out <- paste0("[", format(l), ",", format(r), "]")
  out[is.na(x)] <- NA
  out
}

x <- new_interval(c(0.25, 0.5, 0.75, NA), c(0.5, 1.5, 2, NA))
x
```

Arithmetic operations are provided by a single generic, `vec_arith()`, which like `vec_cast()` and `vec_type2()`, uses double dispatch. That means we start with some boilerplate:

```{r}
vec_arith.vctrs_interval <- function(op, x, y) {
  UseMethod("vec_arith.vctrs_interval", y)
}
vec_arith.vctrs_interval.default <- function(op, x, y) {
  stop_incompatible_op(op, x, y)
}
```

First, we'll implement a method two intervals. <https://en.wikipedia.org/wiki/Interval_arithmetic#Simple_arithmetic>

```{r}
vec_arith.vctrs_interval.vctrs_interval <- function(op, x, y) {
  c(x, y) %<-% vec_recycle(x, y)
  
  x1 <- field(x, "l"); x2 <- field(x, "r")
  y1 <- field(y, "l"); y2 <- field(y, "r")
  
  switch(op,
    "+" = new_interval(x1 + y1, x2 + y2),
    "-" = new_interval(xl - y2, x2 - y1),
    "*" = new_interval(
      pmin(x1 * y1, x1 * y2, x2 * y1, x2 * y2), 
      pmax(x1 * y1, x1 * y2, x2 * y1, x2 * y2)
    ),
    stop_incompatible_op(op, x, y)
  )
}

x + interval(0, 1)

x * interval(0, 1)
x * interval(1, 2)
```

```{r}
vec_arith.vctrs_interval.double <- function(op, x, y) {
  c(x, y) %<-% vec_recycle(x, y)
  
  l <- vec_arith_base(op, field(x, "l"), y)
  r <- vec_arith_base(op, field(x, "r"), y)
  
  new_interval(pmin(l, r), pmax(l, r))
}

x + 1
x / 2
x * -2 
```

```{r}
vec_arith.numeric.vctrs_interval <- function(op, x, y) {
  c(x, y) %<-% vec_recycle(x, y)
  
  l <- vec_arith_base(op, x, field(y, "l"))
  r <- vec_arith_base(op, x, field(y, "r"))
  
  new_interval(pmin(l, r), pmax(l, r))
}

1 + x
2 / x 
-2 * x 
```

(Note that this implementation prevents subclassing because we explicitly call `new_interval()`. If you wanted to support subclassing, you'd need to carefully think about how to use `vec_restore()`.)

```{r}
vec_arith.vctrs_interval.MISSING <- function(op, x, y) {
  switch(op, 
    `-` = x * -1,
    `+` = x,
    stop_incompatible_op(op, x, y)
  )
}
-x 
+x
```


